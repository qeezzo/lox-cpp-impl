// This file was generated by GenerateAst
#pragma once
#include "../Types/Token.h"
#include <functional>
#include <type_traits>

using namespace lox;

class BinaryExpr;
class GroupingExpr;
class LiteralExpr;
class UnaryExpr;
class VariableExpr;
class AssignExpr;
class LogicalExpr;
class CallExpr;

class ExprVisitor {
public:
    virtual ~ExprVisitor() = default;
    virtual Types::Literal visit(BinaryExpr* expr) = 0;
    virtual Types::Literal visit(GroupingExpr* expr) = 0;
    virtual Types::Literal visit(LiteralExpr* expr) = 0;
    virtual Types::Literal visit(UnaryExpr* expr) = 0;
    virtual Types::Literal visit(VariableExpr* expr) = 0;
    virtual Types::Literal visit(AssignExpr* expr) = 0;
    virtual Types::Literal visit(LogicalExpr* expr) = 0;
    virtual Types::Literal visit(CallExpr* expr) = 0;
};

class Expr {
public:
    virtual ~Expr() = default;
    virtual Types::Literal accept(ExprVisitor* visitor) = 0;
};

class CallExpr : public Expr {
public:
    Expr* callee;
    Types::Token paren;
    std::vector<Expr*> arguments;

    CallExpr(Expr* callee, Types::Token paren, std::vector<Expr*> arguments) :
        callee(callee), paren(paren), arguments(arguments)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class LogicalExpr : public Expr {
public:
    Expr* left;
    Types::Token op;
    Expr* right;

    LogicalExpr(Expr* left, Types::Token op, Expr* right) :
        left(left), op(op), right(right)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class AssignExpr : public Expr {
public:
    Types::Token name;
    Expr* value;

    AssignExpr(Types::Token name, Expr* value) :
        name(name), value(value)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class BinaryExpr : public Expr {
public:
    Expr* left;
    Types::Token op;
    Expr* right;

    BinaryExpr(Expr* left, Types::Token op, Expr* right) :
        left(left), op(op), right(right)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class VariableExpr : public Expr {
public:
    Types::Token name;

    VariableExpr(Types::Token token) :
        name(token)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class GroupingExpr : public Expr {
public:
    Expr* expr;

    GroupingExpr(Expr* expr) :
        expr(expr)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class LiteralExpr : public Expr {
public:
    Types::Literal value;

    LiteralExpr(Types::Literal literal) :
        value(literal)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};

class UnaryExpr : public Expr {
public:
    Types::Token op;
    Expr* right;

    UnaryExpr(Types::Token op, Expr* right) :
        op(op), right(right)
    { }
    Types::Literal accept(ExprVisitor* visitor) override {
        return visitor->visit(this);
    };
};
