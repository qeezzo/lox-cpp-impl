#include <algorithm>
#include <cctype>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <vector>
using namespace std;

void defineAst(string outputDir, string baseName, vector<pair<string, string>> types);
void defineType(ostream& os, const string& base, const string& className, const vector<pair<string, string>>& params);
void defineVisitor(ostream& os, const string& base, const vector<pair<string, string>> types);


int main(int argc, char* argv[])
{
    if (argc != 2)
    {
        cout << "Usage: generate_ast <output directory>" << endl;
        exit(64);
    }

    //defineAst(argv[1], "Expr", vector<pair<string, string>> {
    //        { "BinaryExpr",    "Expr* left, Types::Token op, Expr* right" },
    //        { "GroupingExpr",  "Expr* expr" },
    //        { "LiteralExpr",   "Types::OptionalLiteral value" },
    //        { "UnaryExpr",     "Types::Token op, Expr* right" }
    //    });

    defineAst(argv[1], "Stmt", vector<pair<string, string>> {
            { "Expression",     "Expr* expr" },
            { "Print",          "Expr* expr" }
        });
}

void defineAst(string outputDir, string baseName, vector<pair<string, string>> types)
{
    // create directory if it doesnt already exist
    filesystem::create_directories(outputDir);

    string path = outputDir + "/" + baseName + ".h";

    ofstream file (path, ios_base::trunc);

    file << "// This file was generated by GenerateAst\n";
    file << "#pragma once\n";
    file << "#include \"../Types/Token.h\"\n\n";
    file << "using namespace lox;\n\n";

    // forward declaration
    for (auto& [type, fields] : types)
        file << "class " << type << ";\n";
    file << "\n";

    defineVisitor(file, baseName, types);

    file << "class " << baseName << " {\n";
    file << "public:\n";
    file << "\t" << baseName << "() = default;\n";
    file << "\tvirtual ~" << baseName << "() = default;\n";
    file << "\tvirtual void accept(ExprVisitor* visitor) = 0;\n";
    file << "};\n\n";

    for (auto& [type, fields] : types) {

        istringstream typestream (fields);
        vector<pair<string, string>> params;

        while (typestream)
        {
            string type;
            string name;
            typestream >> type;
            typestream >> ws;
            getline(typestream, name, ',');
            params.push_back({std::move(type), std::move(name)});
        }

        params.pop_back();
        defineType(file, baseName, type, params);
    }

    file.flush();
}

void defineType(ostream& os, const string& base, const string& className, const vector<pair<string, string>>& params)
{
    os << "class " << className << " : public " << base << " {\n";
    os << "public:\n";

    // fields of class
    for (size_t i{} ; i < params.size(); ++i)
        os << "\t" << params[i].first << " " << params[i].second << ";\n";
    os << "\n";

    // constructor
    os << "\t" << className << "(";
    for (size_t i{} ; i < params.size(); ++i)
        os << params[i].first << " " << params[i].second << (i != params.size() - 1 ? ", " : "");
    os << ") :\n";
    os << "\t\t";
    for (size_t i{} ; i < params.size(); ++i)
        os << params[i].second << "(" << params[i].second << ")" << (i != params.size() - 1 ? ", " : "\n\t{ }\n");

    // accept function
    os << "\tvoid accept(ExprVisitor* visitor) override {\n";
    os << "\t\tvisitor->visit" << "(this);\n";
    os << "\t};\n";

    os << "};\n\n";
}

void defineVisitor(ostream& os, const string& base, const vector<pair<string, string>> types)
{
    os << "class ExprVisitor {\n";
    os << "public:\n";
    os << "\tvirtual ~ExprVisitor() = default;\n";

    string base_lower(base);
    transform(base_lower.begin(), base_lower.end(), base_lower.begin(),
            [](unsigned char c) { return tolower(c); });

    for (auto& type : types)
        os << "\tvirtual void visit" << "(" << type.first 
           << "* " << base_lower << ") = 0;\n";

    os << "};\n";
}
